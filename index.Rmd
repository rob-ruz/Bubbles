---
title: "Caso"
author: "Roberto Ruz Campos"
date: "30/11/2019"
output:
  html_document:
    df_print: paged
---

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(lubridate)
library(rvest)
library(janitor)
library(readxl)
```

Se importa la tabla "Compustat Global Daily" con los tipos de datos correctos.
```{r}
global_daily <- read_csv("Compustat_Global_Daily.csv",
  col_types = cols(
    sedol = col_character(),
    datadate = col_date(format = "%Y%m%d")
  )
)
```

Extraemos de Wikipedia la tabla de códigos GICS con sus respectivos nombres.

```{r message=FALSE, warning=FALSE}
gics_table <- read_html("https://en.wikipedia.org/wiki/Global_Industry_Classification_Standard") %>%
  html_node("table") %>%
  html_table(fill = TRUE) %>%
  as_tibble(.name_repair = "universal") %>%
  distinct(gsector = Sector...1, gics_name = Sector...2)
```

Se le añaden los nombres de los sectores a la tabla original
```{r}
global_daily <- left_join(global_daily, gics_table, by = "gsector")
```

# ETAPA 1: CÁLCULO DE RENDIMIENTOS.

## Filtros de país y moneda. 

De la base original extraemos un subconjunto de datos. Este subconjunto corresponde a los registros con valor 208 en la columna "exchg".
```{r}
#Creamos un nuevo data frame, en caso de querer regresar a este punto.
DatosMX01 <- global_daily %>%
  filter(exchg == 208)
# Generamos un resumen para ver los resultados del filtro.
DatosMX01 %>%
  group_by(exchg) %>%
  count(curcdd)
# Solo quedan registros en MXP, MXN, NA y 1 registro en USD.    
```

```{r}
# Se elimina el registro con "curcdd" en dólares.
DatosMX01 <- DatosMX01 %>%
  filter(!curcdd %in% "USD")

# Generamos un data frame para revisar las características de los registros que en el campo "curcdd" tienen "NA".
DatosMX01 %>%
  filter(is.na(curcdd))  

# Generamos una tabla de resumen para identificar si estos registros tienen información de precios.
DatosMX01 %>%
  summarise_all(~ sum(is.na(.)))

# El resumen muestra que los registros que en el campo "curcdd" tienen "NA", no tienen registro de precios.
# Por lo tanto los eliminamos de "DatosMX01".
DatosMX01 <- DatosMX01 %>%
  filter(!is.na(curcdd))

# Imprimimos una tabla de resumen. 
DatosMX01 %>%
  group_by(exchg) %>%
  count(curcdd)

```

## Duplicidad de fechas

Es importante tener en cuenta que un `GVKEY` es un número único asignado a cada compañía en la base de datos de Compustat (ver: https://libguides.stanford.edu/c.php?g=559845&p=6686228). El `GVKEY` puede ser utilizado en lugar del `CUSIP`, un identificador equivalente al `ISIN`. Asimismo, el `Issue ID` (`iid`) es un código alfanumérico único para cada emisión de valores de una compañía (`GVKEY`) (ver: https://library.unist.ac.kr/libguide/wp-content/uploads/sites/2/2018/11/compustat.pdf)

En el código del siguiente chunk, analizamos la relación entre `GVKEY` e `isin`

```{r}
# Generamos un identificador único concatenando el campo "gvkey" con "iid".
DatosMX01 <- DatosMX01 %>% 
  mutate(gvkey_iid = paste(gvkey, iid, sep = "_")) %>% 
  select(gvkey_iid, everything())

# Generamos un resumen para identificar la cantidad de distintos `isin` asociados a un único "GVKEY_IID".
# Notemos que existen algunas emisiones (gvkey_iid) que no cuentan con isin
DatosMX01 %>%
  group_by(conm, gvkey_iid, isin) %>%
  summarise(
    distinct_isin = n_distinct(isin),
    count_isin = n()
  ) 

# Puede comprobarse que hay más gvkey_iid que isin
DatosMX01 %>%
  summarise_all(n_distinct)
```

Las tablas anteriores muestran que cada código "GVKEY-IID" está asociado a un único "isin". 
Hay varios códigos "GVKEY-IID" en  el que"isin" es "NA", entonces . Revisamos las características de este conjunto de datos.

```{r}
DatosMX01 %>%
  group_by(gvkey_iid) %>%
  filter(is.na(isin)) 

```

Aún cuando el "isin" es "NA", los registros tienen información de precios y otra información relevante. Al estar identificados con "gvkey" y "iid", no es relevante que no contengan "isin".

<p style="color:red">**NOTA: Debe notarse que un "gvkey" está asociado a un nombre de empresa. Esto implica que si sólo analizamos los "gvkey" encontraremos fechas duplicadas. Pero no sería adecuado eliminar los registros con fechas duplicadas, pues pueden corresponder a una emisión ("iid") diferente.**</p>

Verificamos entonces cuáles son los `gvkey_iid` que tienen alguna fecha duplicada.
```{r}
# Cuales son el combinado de fecha/emisora que aparecen en la base más de una vez  y los extraemos hacia un vector
get_dupes(DatosMX01, gvkey_iid, datadate)
```
No hay fechas duplicadas.

## Precio ajustado y capitalización de mercado.

Para calcular los precios ajustados, primero revisamos si existen precios(prccd) negativos y luego realizamos los cálculos correspondientes.

```{r}
#Revisamos si hay precios negativos.
DatosMX01 %>%
  filter(prccd <= 0)

#No se identificaron precios negativos. 
# Vemos que si hay registros con "NA" en el campo "prccd".
DatosMX01 %>%
  summarise(prcdd_na = sum(is.na(prccd)))
#No se identificaron registros con NA en "prccd". Procedemos con los cálculos.

# Para los registros previos al 1 de enero de 1993, dividimos prccd entre 1000 para convertirlos en MXN.
# Entonces, calculamos el Precio ajustado.
# Calculamos el Valor de Mercado (SIZE).
DatosMX01 <- DatosMX01 %>%
  mutate(
    prccd = ifelse(curcdd == "MXP", prccd / 1000, prccd),
    Precio = (prccd / ajexdi) * trfd,
    Size = prccd * cshoc / 1000000
  )

#NA EN size
DatosMX01 %>%
  filter(is.na(Size))
```
<p style="color:red">**NOTA: Hay que tener en la carpeta local del proyecto el archivo "Sectores_GICS_BMV"**</p>

```{r}
sectores <- read_xlsx(
  path = "Sectores_GICS_BMV.xlsx",
  sheet = "Sectores",
  range = "A1:E292",
  col_names = TRUE,
  col_types = c("text")
)

DatosMX01 <- DatosMX01 %>% 
  left_join(select(sectores, gvkey, BMV), by = "gvkey")
```

## Análisis de sectores por empresas
```{r}
DatosMX01 %>% 
  mutate(year = year(datadate)) %>% 
  group_by(year, BMV) %>% 
  summarise(n = n_distinct(conm)) %>%
  spread(year, n)
  
```
## Selección por Valor de Mercado.

**En esta sección propongo analizar gráficamente la serie de valor de mercado por cada "gvkey" y sus emisiones (iid) correspondientes, para elegir aquella emisión que mantendremos en la muestra para el ejercicio de burbujas.**


```{r}
# de los gvkey que tienen mas de una emisión... cual es el valor de mercado promedio de cada emisión por empresa, se pone en un vector la emisión que más valor de mercado tenga para quedarse con dicha emisión...
(DatosMX01 %>%
  group_by(gvkey) %>%
  filter(n_distinct(iid) > 1) %>%
  group_split() %>%
  map(
    ~ group_by(.x, gvkey, iid) %>%
      summarise(
        prom_vm = mean(Size, na.rm = TRUE)
      ) %>%
      top_n(1, prom_vm) %>%
      ungroup() %>%
      select(gvkey, iid)
  ) %>%
  map_chr(~ paste(.x[[1]], .x[[2]], sep = "_")) -> emisoras_keep)
```

```{r}
(DatosMX01 %>%
  group_by(gvkey) %>%
  filter(n_distinct(iid) == 1) %>%
  distinct(gvkey, iid) %>%
  map2_chr(
    .x = .$gvkey,
    .y = .$iid,
    .f = ~ paste(.x, .y, sep = "_")
  ) %>%
  c(emisoras_keep, .) -> emisoras_keep)
```

```{r}
#Estos serían los registros que nos quedarían
DatosMX01 %>%
  filter(gvkey_iid %in% emisoras_keep) %>% 
  arrange(datadate, gvkey)
```


```{r}
#Prueba 1
DatosMX01 %>%
  select(gvkey_iid, datadate, Precio) %>%
  mutate(year = year(datadate)) %>%
  mutate(month = month(datadate)) %>%
  group_by(year, month) %>%
  spread(gvkey_iid, Precio)

#Prueba 2
DatosMX01 %>%
  select(gvkey_iid, datadate, monthend, Precio) %>%
  mutate(year = year(datadate)) %>%
  mutate(month = month(datadate)) %>%
  group_by(year, month) %>%
  spread(gvkey_iid, Precio) %>%
  filter(monthend == 1)


# Serie de dataframes (uno por año) con el numero de precios de las emisoras que en ese año cotizaron desglosado por mes
DatosMX01 %>%
  mutate(
    year = year(datadate),
    month = paste(month(datadate, label = TRUE), year(datadate))
  ) %>%
  group_by(year) %>%
  group_split() %>%
  modify(~ group_by(.x, gvkey_iid, conm, month) %>%
    summarise(n = length(Precio)) %>%
    spread(month, n))
  
# Cuantos precios monthend hay por mes cada año para cada emisora 
DatosMX01 %>%
  mutate(
    year = year(datadate),
    month = paste(month(datadate, label = TRUE), year(datadate))
  ) %>%
  filter(monthend == 1) %>% 
  group_by(year) %>%
  group_split() %>%
  modify(~ group_by(.x, gvkey_iid, conm, month) %>%
    summarise(n = length(Precio)) %>%
    spread(month, n))
```
## Filtros de fin de mes.

**Hasta aquí voy. Es posible que además de elegir los registros con "monthend==1", debamos establecer otra condición para identificar algún otro precio observado y evitar tener "missing" values.**

Ahora, nos quedamos unicamente con los "monthend" 
```{r}
# Dejamos únicamente los registros identificados como "monthend".
return_records <- DatosMX01 %>%
  filter(monthend == 1)
```


