---
title: "Caso"
author: "Roberto Ruz Campos"
date: "30/11/2019"
output:
  html_document:
    df_print: paged
---

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(lubridate)
library(rvest)
library(janitor)
library(readxl)
```

Se importa la tabla "Compustat Global Daily" con los tipos de datos correctos.
```{r}
global_daily <- read_csv("Compustat_Global_Daily.csv",
  col_types = cols(
    sedol = col_character(),
    datadate = col_date(format = "%Y%m%d")
  )
)
```

Extraemos de Wikipedia la tabla de códigos GICS con sus respectivos nombres.

```{r message=FALSE, warning=FALSE}
gics_table <- read_html("https://en.wikipedia.org/wiki/Global_Industry_Classification_Standard") %>%
  html_node("table") %>%
  html_table(fill = TRUE) %>%
  as_tibble(.name_repair = "universal") %>%
  distinct(gsector = Sector...1, gics_name = Sector...2)
```

Se le añaden los nombres de los sectores a la tabla original
```{r}
global_daily <- left_join(global_daily, gics_table, by = "gsector")
```

Tipo de variable de cada columna
```{r}
global_daily %>%
  summarise_all(class) %>%
  pivot_longer(everything(), names_to = "column", values_to = "type")
```

# ETAPA 1: CÁLCULO DE RENDIMIENTOS.

## Filtros de país y moneda. 

De la base original extraemos un subconjunto de datos. Este subconjunto corresponde a los registros con valor 208 en la columna "exchg".
```{r}
#Creamos un nuevo data frame, en caso de querer regresar a este punto.
DatosMX01 <- global_daily %>%
  filter(exchg == 208)
# Generamos un resumen para ver los resultados del filtro.
DatosMX01 %>%
  group_by(exchg) %>%
  count(curcdd)
# Solo quedan registros en MXP, MXN, NA y 1 registro en USD.    
```

```{r}
# Se elimina el registro con "curcdd" en dólares.
DatosMX01 <- DatosMX01 %>%
  filter(!curcdd %in% "USD")

# Generamos un data frame para revisar las características de los registros que en el campo "curcdd" tienen "NA".
DatosMX01 %>%
  filter(is.na(curcdd))  

# Generamos una tabla de resumen para identificar si estos registros tienen información de precios.
DatosMX01 %>%
  summarise_all(~ sum(is.na(.)))

# El resumen muestra que los registros que en el campo "curcdd" tienen "NA", no tienen registro de precios.
# Por lo tanto los eliminamos de "DatosMX01".
DatosMX01 <- DatosMX01 %>%
  filter(!is.na(curcdd))

# Imprimimos una tabla de resumen. 
DatosMX01 %>%
  group_by(exchg) %>%
  count(curcdd)

```

## Duplicidad de fechas

Es importante tener en cuenta que un `GVKEY` es un número único asignado a cada compañía en la base de datos de Compustat (ver: https://libguides.stanford.edu/c.php?g=559845&p=6686228). El `GVKEY` puede ser utilizado en lugar del `CUSIP`, un identificador equivalente al `ISIN`. Asimismo, el `Issue ID` (`iid`) es un código alfanumérico único para cada emisión de valores de una compañía (`GVKEY`) (ver: https://library.unist.ac.kr/libguide/wp-content/uploads/sites/2/2018/11/compustat.pdf)

En el código del siguiente chunk, analizamos la relación entre `GVKEY` e `isin`

```{r}
# Generamos un identificador único concatenando el campo "gvkey" con "iid".
DatosMX01 <- DatosMX01 %>% 
  mutate(gvkey_iid = paste(gvkey, iid, sep = "_")) %>% 
  select(gvkey_iid, everything())

# Generamos un resumen para identificar la cantidad de distintos `isin` asociados a un único "GVKEY_IID".
# Notemos que existen algunas emisiones (gvkey_iid) que no cuentan con isin
DatosMX01 %>%
  group_by(conm, gvkey_iid, isin) %>%
  summarise(
    distinct_isin = n_distinct(isin),
    count_isin = n()
  ) 

# Puede comprobarse que hay más gvkey_iid que isin
DatosMX01 %>%
  summarise_all(n_distinct)
```

Las tablas anteriores muestran que cada código "GVKEY-IID" está asociado a un único "isin". 
Hay varios códigos "GVKEY-IID" en  el que"isin" es "NA", entonces . Revisamos las características de este conjunto de datos.

```{r}
DatosMX01 %>%
  group_by(gvkey_iid) %>%
  filter(is.na(isin)) 

```

Aún cuando el "isin" es "NA", los registros tienen información de precios y otra información relevante. Al estar identificados con "gvkey" y "iid", no es relevante que no contengan "isin".

<p style="color:red">**NOTA: Debe notarse que un "gvkey" está asociado a un nombre de empresa. Esto implica que si sólo analizamos los "gvkey" encontraremos fechas duplicadas. Pero no sería adecuado eliminar los registros con fechas duplicadas, pues pueden corresponder a una emisión ("iid") diferente.**</p>

Verificamos entonces cuáles son los `gvkey_iid` que tienen alguna fecha duplicada.
```{r}
# Cuales son el combinado de fecha/emisora que aparecen en la base más de una vez  y los extraemos hacia un vector
get_dupes(DatosMX01, gvkey_iid, datadate)
```
No hay fechas duplicadas.

## Precio ajustado y capitalización de mercado.

Para calcular los precios ajustados, primero revisamos si existen precios(prccd) negativos y luego realizamos los cálculos correspondientes.

```{r}
#Revisamos si hay precios negativos.
DatosMX01 %>%
  filter(prccd <= 0)

#No se identificaron precios negativos. 
# Vemos que si hay registros con "NA" en el campo "prccd".
DatosMX01 %>%
  summarise(prcdd_na = sum(is.na(prccd)))
#No se identificaron registros con NA en "prccd". Procedemos con los cálculos.

# Para los registros previos al 1 de enero de 1993, dividimos prccd entre 1000 para convertirlos en MXN.
# Entonces, calculamos el Precio ajustado.
# Calculamos el Valor de Mercado (SIZE).
DatosMX01 <- DatosMX01 %>%
  mutate(
    prccd = ifelse(curcdd == "MXP", prccd / 1000, prccd),
    Precio = (prccd / ajexdi) * trfd,
    Size = prccd * cshoc / 1000000
  )


sectores <- read_xlsx(
  path = "Sectores_GICS_BMV.xlsx",
  sheet = "Sectores",
  range = "A1:E261",
  col_names = TRUE,
  col_types = c("text")
)

```

## Selección por Valor de Mercado.

**En esta sección propongo analizar gráficamente la serie de valor de mercado por cada "gvkey" y sus emisiones (iid) correspondientes, para elegir aquella emisión que mantendremos en la muestra para el ejercicio de burbujas.**

## Filtros de fin de mes.

**Hasta aquí voy. Es posible que además de elegir los registros con "monthend==1", debamos establecer otra condición para identificar algún otro precio observado y evitar tener "missing" values.**

Ahora, nos quedamos unicamente con los "monthend" y creamos la variable de precios con la que se calcularán los retornos.
```{r}
# Dejamos únicamente los registros identificados como "monthend".
return_records <- DatosMX01 %>%
  filter(monthend == 1)
```


