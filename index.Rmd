---
title: "Caso"
author: "Roberto Ruz Campos"
date: "30/11/2019"
output:
  html_document:
    df_print: paged
---

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(lubridate)
library(janitor)
library(readxl)
library(tsibble)
```

Se importa la tabla "Compustat Global Daily" con los tipos de datos correctos.
```{r}
global_daily <- read_csv("Compustat_Global_Daily.csv",
  col_types = cols(
    sedol = col_character(),
    datadate = col_date(format = "%Y%m%d")
  )
)
```

Se agregan el sector correspondiente a cada empresa según la clasificación de la BMV
<p style="color:red">
**NOTA: Hay que tener en la carpeta local del proyecto el archivo "Sectores_GICS_BMV"**
</p>

```{r}
global_daily <- read_xlsx(
  path = "Sectores_GICS_BMV.xlsx",
  sheet = "Sectores",
  range = "A1:D292",
  col_names = TRUE,
  col_types = c("text")
) %>%
  select(gvkey, BMV) %>%
  left_join(
    global_daily,
    .,
    by = "gvkey"
  )
```

## Filtros de país y moneda. 

De la base original extraemos un subconjunto de datos. Este subconjunto corresponde a los registros con valor 208 en la columna "exchg".
```{r}
#Creamos un nuevo data frame, en caso de querer regresar a este punto.
DatosMX01 <- global_daily %>%
  filter(
    exchg == 208,
    !curcdd %in% "USD"
  )

# Generamos un resumen para ver los resultados del filtro.
DatosMX01 %>%
  group_by(exchg) %>%
  count(curcdd)
# Solo quedan registros en MXP, MXN, NA    

# Revisar las características de los registros que en el campo "curcdd" tienen "NA" e identificar si estos registros tienen información de precios.
DatosMX01 %>%
  summarise_all(~ sum(is.na(.)))

DatosMX01 %>% 
  filter(is.na(curcdd))

# El resumen muestra que los registros que en el campo "curcdd" tienen "NA", no tienen registro de precios.Por lo tanto los eliminamos de "DatosMX01".
DatosMX01 <- DatosMX01 %>%
  filter(!is.na(curcdd))

```

## Duplicidad de fechas

Es importante tener en cuenta que un `GVKEY` es un número único asignado a cada compañía en la base de datos de Compustat (ver: https://libguides.stanford.edu/c.php?g=559845&p=6686228). El `GVKEY` puede ser utilizado en lugar del `CUSIP`, un identificador equivalente al `ISIN`. Asimismo, el `Issue ID` (`iid`) es un código alfanumérico único para cada emisión de valores de una compañía (`GVKEY`) (ver: https://library.unist.ac.kr/libguide/wp-content/uploads/sites/2/2018/11/compustat.pdf)

En el código del siguiente chunk, analizamos la relación entre `GVKEY` e `isin`

```{r}
# Generamos un identificador único concatenando el campo "gvkey" con "iid".
DatosMX01 <- DatosMX01 %>% 
  mutate(gvkey_iid = paste(gvkey, iid, sep = "_")) %>% 
  select(gvkey_iid, everything())


# Generamos un resumen para identificar la cantidad de distintos `isin` asociados a un único "GVKEY_IID".
# Notemos que existen algunas emisiones (gvkey_iid) que no cuentan con isin
DatosMX01 %>%
  group_by(conm, gvkey_iid, isin) %>%
  summarise(
    distinct_isin = n_distinct(isin),
    count_isin = n()
  ) 

# Puede comprobarse que hay más gvkey_iid que isin
DatosMX01 %>%
  summarise_all(n_distinct)
```

Las tablas anteriores muestran que cada código "GVKEY-IID" está asociado a un único "isin". 
Hay varios códigos "GVKEY-IID" en  el que"isin" es "NA", entonces . Revisamos las características de este conjunto de datos.

```{r}
DatosMX01 %>%
  group_by(gvkey_iid) %>%
  filter(is.na(isin)) 

```

Aún cuando el "isin" es "NA", los registros tienen información de precios y otra información relevante. Al estar identificados con "gvkey" y "iid", no es relevante que no contengan "isin".

<p style="color:red">**NOTA: Debe notarse que un "gvkey" está asociado a un nombre de empresa. Esto implica que si sólo analizamos los "gvkey" encontraremos fechas duplicadas. Pero no sería adecuado eliminar los registros con fechas duplicadas, pues pueden corresponder a una emisión ("iid") diferente.**</p>

Verificamos entonces cuáles son los `gvkey_iid` que tienen alguna fecha duplicada.
```{r}
# Cuales son el combinado de fecha/emisora que aparecen en la base más de una vez  y los extraemos hacia un vector
get_dupes(DatosMX01, gvkey_iid, datadate)
```
No hay fechas duplicadas.

## Precio ajustado y capitalización de mercado.

Para calcular los precios ajustados, primero revisamos si existen precios(prccd) negativos y luego realizamos los cálculos correspondientes.

```{r}

# Para los registros previos al 1 de enero de 1993, dividimos prccd entre 1000 para convertirlos en MXN.
# Entonces, calculamos el Precio ajustado.
# Calculamos el Valor de Mercado
DatosMX01 <- DatosMX01 %>%
  mutate(
    prccd = ifelse(curcdd == "MXP", prccd / 1000, prccd),
    adj_price = (prccd / ajexdi) * trfd,
    mv = prccd * cshoc / 1000000
  )

#NA EN mv
DatosMX01 %>%
  filter(is.na(mv))
```


## Análisis de sectores por empresas
```{r}
DatosMX01 %>% 
  mutate(year = year(datadate)) %>% 
  group_by(year, BMV) %>% 
  summarise(n = n_distinct(conm)) %>%
  spread(year, n)
  
```
## Selección por Valor de Mercado.


```{r}
# de los gvkey que tienen mas de una emisión... cual es el valor de mercado promedio de cada emisión por empresa, se pone en un vector la emisión que más valor de mercado tenga para quedarse con dicha emisión...

keep_emisoras <- DatosMX01 %>% 
  group_by(gvkey, iid) %>%
  summarise(prom_mv = mean(mv, na.rm = TRUE)) %>% 
  filter(n_distinct(iid) > 1) %>% 
  top_n(1, prom_mv) %>% 
  mutate(gvkey_iid = paste(gvkey, iid, sep = "_")) %>% 
  pull(gvkey_iid) 

keep_emisoras <- c(
  keep_emisoras,
  DatosMX01 %>%
    group_by(gvkey, iid) %>%
    summarise(prom_mv = mean(mv, na.rm = TRUE)) %>%
    filter(n_distinct(iid) == 1) %>%
    mutate(gvkey_iid = paste(gvkey, iid, sep = "_")) %>%
    pull(gvkey_iid)
)

### CHECKPOINT ###
#Estos serían los registros que nos quedarían
DatosMX01 <- DatosMX01 %>%
  filter(gvkey_iid %in% keep_emisoras) %>% 
  arrange(datadate, gvkey) 

one_record_filt <- DatosMX01 %>% 
  count(gvkey_iid) %>% 
  filter(n == 1) %>% 
  pull(gvkey_iid)

DatosMX01 <- DatosMX01 %>% 
  filter(!gvkey_iid %in% one_record_filt)


DatosMX01 <- DatosMX01 %>% mutate(
  year = year(datadate),
  mes = yearmonth(datadate)
)

alt_DatosMX01 <- DatosMX01
```

**Hasta aquí todo es igual en las dos variantes de código

```{r eval=FALSE, include=FALSE}
# Serie de dataframes (uno por año) con el numero de precios de las emisoras que en ese año cotizaron desglosado por mes
DatosMX01 %>%
  group_by(year) %>%
  group_split() %>%
  modify(
    ~ group_by(.x, gvkey_iid, conm, mes) %>%
      summarise(n = length(mv)) %>%
      pivot_wider(names_from = mes, values_from = n) 
  )

# Cuantos precios monthend hay por mes cada año para cada emisora 
DatosMX01 %>%
  filter(monthend == 1) %>%
  group_by(year) %>%
  group_split() %>%
  modify(
    ~ group_by(.x, gvkey_iid, conm, mes) %>%
    summarise(n = length(mv)) %>%
    pivot_wider(names_from = mes, values_from = n) 
  )

```

## Filtros de fin de mes.

Ahora, nos quedamos unicamente con los "monthend" 
```{r}
# Dejamos únicamente los registros identificados como "monthend".
datos_mensuales <- DatosMX01 %>%
  filter(monthend == 1) 
```

```{r}
#############################################################
##    ATENCIÓN: Hay que tener instalado el paquete tsibble ##
##              install.packages("tsibble")                ##
##                  library(tsibble)                       ##
############################################################

# Para comparar... ¿Cómo estaban antes?
# en una pequeña muestra...
DatosMX01 %>%
  filter(
    gvkey %in% c("221592", "028535"),
    monthend == 1
  ) 

# Código rellenador hasta el momento se hace para una determinada empresa, pero sería fácil escalarlo a todas...(¿?)

DatosMX01 %>%
  filter(
    gvkey %in% c("221592", "028535"),
    monthend == 1
  ) %>%
  as_tsibble(
    key = gvkey_iid,
    index = mes
  ) %>%
  fill_gaps() %>%
  fill(-datadate, -year, .direction = "down") %>%
  mutate(
    datadate = if_else(
      is.na(datadate),
      make_date(
        year = year(mes),
        month = month(mes),
        day = days_in_month(month(mes))
      ),
      datadate
    ),
    year = year(mes)
  )
```
Rellenado de todas las empresas

```{r}
datos_mensuales <- datos_mensuales %>%
  as_tsibble(
    key = gvkey_iid,
    index = mes
  ) %>%
  fill_gaps() %>%
  fill(-datadate, -year, .direction = "down") %>%
  mutate(
    datadate = if_else(
      is.na(datadate),
      make_date(
        year = year(mes),
        month = month(mes),
        day = days_in_month(month(mes))
      ),
      datadate
    ),
    year = year(mes)
  ) %>% 
  arrange(datadate)
```

## Creación de rendimientos..
```{r}
datos_mensuales %>% 
  as_tibble() %>% 
  select(gvkey_iid, datadate, adj_price, BMV) %>% 
  group_by(gvkey_iid) %>% 
  mutate(returns = (adj_price / lag(adj_price)) - 1) %>% 
  group_by(BMV) %>% 
  group_split()
```

***

# Variante de Armando

## Filtros de fin de mes.
Enseguida vamos a generar dos data frames.
Uno contiene a las observaciones que son fin de mes (DatosMX02), 
y el otro al resto de observaciones (DFnoFinMes).
Del segundo de estos data frames, identificaremos aquellos "gvkey_iid" + "año-mes" que no tienen un identificador igual en el data frame de fin de mes; estas observaciones las utilizaremos para insertarlas en DatosMX02.

```{r}
# Generamos entonces el data frame que tiene las observaciones que SÍ son "fin de mes". 
DatosMX02 <- DatosMX01 %>% filter(monthend == 1)

# Vemos que hay observaciones que tienen NA en el campo "cshoc". Por el momento no usamos esta información.
DatosMX02 %>% filter(is.na(cshoc))

# Vemos que hay "observaciones "gvkey_iid" con una sóla observación. Por el momento no usamos esta información.
DatosMX02 %>% count(gvkey_iid) %>% filter(n == 1) 

# Generamos ahora el data frame con las observaciones que no son fin de mes, hasta la ejecución de estas instrucciones, la suma de estas observaciones y las observaciones del filtro anterior resultan en el total de observaciones en "DatosMX01".
DFnoFinMes <- DatosMX01 %>% filter(monthend != 1)

# Verificamos la cantidad de registros de "fin de mes" por "gvkey_iid". 
DatosMX02 %>%
  group_by(gvkey_iid, month = format(datadate, "%Y%m")) %>%
  summarise(n = n()) %>%
  filter(n > 1) %>%
  spread(month, n)
# NO hay "gvkey_iid" con más de un "fin de mes".
```

Para cada "gvkey_iid" identificamos la primer fecha y última para la cual tienen registro de precios en DatosMX02.
Ref: https://stackoverflow.com/questions/53561299/rmin-and-max-of-a-date-column-in-a-dataframe 
```{r}
Rangofechas <- alt_DatosMX01 %>% # Con los datos sin filtrar (antes DatosMX02)
  group_by(gvkey_iid) %>%
  summarise(f_ini = min(datadate), f_fin = max(datadate))
```

En el data frame que contiene los registros que "NO son fin de mes", mantenemos las observaciones correspondientes a la última fecha de cada mes.
Ref: https://stackoverflow.com/questions/55933064/last-observation-for-each-company-for-each-month-r
```{r}
DFnoFinMes <- DFnoFinMes %>%
  mutate(month = yearmonth(datadate)) %>% 
  group_by(
    gvkey_iid,
    month
  ) %>%
  slice(
    which.max(
      datadate 
    )
  ) %>%
  ungroup() %>%
  select(-month)
```


En el data frame que contiene los registros que "NO son fin de mes", para cada "gvkey_iid" + "año-mes", identificamos los meses que sí están en "DatosMX02". Mantenemos sólo las observaciones "gvkey_iid" + "año-mes" que no están en "DatosMX02".

Ref: https://stackoverflow.com/questions/51215628/how-to-perform-an-anti-join-or-left-outer-join-get-all-the-rows-in-a-dataset 
```{r}
DFnoFinMes <- DFnoFinMes %>%
  mutate(
    tempID = paste(
      gvkey_iid,
      format(datadate, "%Y-%m"),
      sep = "_"
    )
  ) %>%
  anti_join(
    (DatosMX02 %>%
      mutate(
        tempID = paste(
          gvkey_iid,
          format(datadate, "%Y-%m"),
          sep = "_"
        )
      )
    ),
    by = "tempID"
  ) %>%
  select(-tempID)
```

Ahora, sólo mantenemos los registros que quedan se encuentran en "Rangofechas", para cada "gvkey_iid".
Ref: https://stackoverflow.com/questions/31353595/checking-if-date-is-between-two-dates-in-r
```{r}
DFnoFinMes <- DFnoFinMes %>%
  inner_join(Rangofechas, by = "gvkey_iid") %>%
  rowwise() %>%
  mutate(match = ifelse(between(datadate, f_ini, f_fin), 1, 0)) %>%
  filter(match == 1) %>%
  select(-c(f_ini, f_fin, match))

# Finalmente, unimos las observaciones de DFnoFInMes a DatosMX02.
DatosMX02 <- union_all(DatosMX02,DFnoFinMes)
rm(DFnoFinMes)
```


## Missing values
A partir de la base anterior, trabajaremos en llenar los missing values.
```{r}
# Eliminamos de "Rangofechas" los "gvkey_iid" que no están en "DatosMX02". 
DatosMX03 <- Rangofechas %>% semi_join(DatosMX02, by="gvkey_iid")
# Ejemplo:
# DatosMX03 <- DatosMX03 %>% filter(gvkey_iid=="021631_01W" | gvkey_iid=="023482_01W")

# Generamos las fechas de fin de mes, para la primera y última observación.
DatosMX03 <- DatosMX03 %>%
  mutate(f_ini=ceiling_date(f_ini,"month")-1)%>%
  mutate(f_fin=ceiling_date(f_fin,"month")-1)
# Generamos una variable que permite contar el número total de meses entre f_ini y f_fin para cada "gvkey_iid".
ControlObs <- DatosMX03 %>%
  mutate(num_meses = (interval(f_ini, f_fin) %/% months(1)) + 1)
# Obtenemos la suma de la variable de control. El total de observaciones debe ser igual a este número.
ControlObs %>% summarise(Obstot=sum(num_meses))
# Generamos la secuencia de fechas entre "Fecha Inicial" y "Fecha Final" para cada "gvkey_iid".
# Ref: https://stackoverflow.com/questions/31873462/creating-sequence-of-dates-for-each-group-in-r
DatosMX03 <- DatosMX03 %>% group_by(gvkey_iid) %>%
  do(data.frame(., Fechas= seq(.$f_ini+1,.$f_fin+1, by = 'month')-1)) %>%
  select(-f_ini,-f_fin)
# Pasamos las observaciones de DatosMX02 a DatosMX03.
# Ref: https://stackoverflow.com/questions/6709151/how-do-i-combine-two-data-frames-based-on-two-columns
DatosMX03 <- (DatosMX03 %>% mutate(ymonth=format(Fechas, "%Y%m"))) %>% 
  left_join((DatosMX02 %>% mutate(ymonth=format(datadate, "%Y%m"))), by=c("gvkey_iid","ymonth"))

DatosMX03<- DatosMX03 %>% group_by(gvkey_iid) %>%
  fill(gvkey,iid,conm,ajexdi,cshoc,prccd,prcstd,trfd,BMV)
# Recalculamos Precio y MV
DatosMX03 <- DatosMX03 %>%
  mutate(
    Precio = (prccd / ajexdi) * trfd,
    MV = prccd * cshoc / 1000000)

# Checks:
DatosMX03 %>% group_by(BMV) %>% distinct(BMV)
DatosMX03 %>% group_by(Fechas) %>% distinct(Fechas)
DatosMX03 %>% group_by(gvkey_iid) %>%  filter(is.na(prccd))
```
#Termina seccion de armando

cherry pick