---
title: "Caso"
author: "Roberto Ruz Campos"
date: "30/11/2019"
output:
  html_document:
    df_print: paged
---

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(lubridate)
library(rvest)
library(janitor)
```

Se importa la tabla "Compustat Global Daily" con los tipos de datos correctos.
```{r}
global_daily <- read_csv("Compustat_Global_Daily.csv",
  col_types = cols(
    sedol = col_character(),
    datadate = col_date(format = "%Y%m%d")
  )
)
```

Extraemos de Wikipedia la tabla de códigos GICS con sus respectivos nombres.

```{r message=FALSE, warning=FALSE}
gics_table <- read_html("https://en.wikipedia.org/wiki/Global_Industry_Classification_Standard") %>%
  html_node("table") %>%
  html_table(fill = TRUE) %>%
  as_tibble(.name_repair = "universal") %>%
  distinct(gsector = Sector...1, gics_name = Sector...2)
```

Se le añaden los nombres de los sectores a la tabla original
```{r}
global_daily <- left_join(global_daily, gics_table, by = "gsector")
```

Tipo de variable de cada columna
```{r}
global_daily %>%
  summarise_all(class) %>%
  pivot_longer(everything(), names_to = "column", values_to = "type")
```

# ETAPA 1: CÁLCULO DE RENDIMIENTOS.

## Filtros de país y moneda. 

De la base original extraemos un subconjunto de datos. Este subconjunto corresponde a los registros con valor 208 en la columna "exchg".
```{r}
#Creamos un nuevo data frame, en caso de querer regresar a este punto.
DatosMX01 <- global_daily %>% filter(exchg == 208)
# Generamos un resumen para ver los resultados del filtro.
DatosMX01 %>% group_by(exchg)%>% count(curcdd)
# Solo quedan registros en MXP, MXN, NA y 1 registro en USD.    
```

```{r}
# Se elimina el registro con "curcdd" en dólares.
DatosMX01 <- DatosMX01 %>% filter(!curcdd %in% "USD")
# Generamos un data frame para revisar las características de los registros que en el campo "curcdd" tienen "NA".
DatosMX_curcddNA <- DatosMX01 %>% filter(is.na(curcdd))  
# Generamos una tabla de resumen para identificar si estos registros tienen información de precios.
DatosMX_curcddNA %>% summarise_all(~ sum(is.na(.)))
# El resumen muestra que los registros que en el campo "curcdd" tienen "NA", no tienen registro de precios.
# Por lo tanto los eliminamos de "DatosMX01".
DatosMX01 <- DatosMX01 %>% filter(!is.na(curcdd))
# Imprimimos una tabla de resumen. 
DatosMX01 %>% group_by(exchg)%>% count(curcdd)
# Eliminamo el data frame "DatosMX_curcddNA".
rm(DatosMX_curcddNA)
```

## Duplicidad de fechas

Es importante tener en cuenta que un `GVKEY` es un número único asignado a cada compañía en la base de datos de Compustat (ver: https://libguides.stanford.edu/c.php?g=559845&p=6686228). El `GVKEY` puede ser utilizado en lugar del `CUSIP`, un identificador equivalente al `ISIN`. Asimismo, el `Issue ID` (`iid`) es un código alfanumérico único para cada emisión de valores de una compañía (`GVKEY`) (ver: https://library.unist.ac.kr/libguide/wp-content/uploads/sites/2/2018/11/compustat.pdf)

En el código del siguiente chunk, analizamos la relación entre `GVKEY` e `isin`

```{r}
# Pasamos la información de "DatosMX01" a otro data frame
DatosMX_gvkey_isin <- DatosMX01
# Generamos un identificador único concatenando el campo "gvkey" con "iid".
DatosMX_gvkey_isin <-unite(DatosMX_gvkey_isin, gvkey_iid, c("gvkey","iid"), sep = "_", remove = FALSE, na.rm = FALSE)
# Generamos un resumen para identificar la cantidad de distintos `isin` asociados a un único "GVKEY_IID".
DatosMX_gvkey_isin %>% group_by(gvkey_iid)%>% summarise(distinct_isin = n_distinct(isin))
DatosMX_gvkey_isin %>% summarise_all(n_distinct)
DatosMX_gvkey_isin %>% group_by(isin)%>% summarise(distinct_gvkey = n_distinct(gvkey_iid))

```

Las tablas anteriores muestran que cada código "GVKEY-IID" está asociado a un único "isin". 
Cuando el "isin" es "NA", entonces hay varios códigos "GVKEY-IID". Revisamos las características de este conjunto de datos.

```{r}
DatosMX_gvkey_isin %>%  group_by(gvkey_iid) %>% filter(is.na(isin)) 
rm(DatosMX_gvkey_isin)
```

Aún cuando el "isin" es "NA", los registros tienen información de precios y otra información relevante. Al estar identificados con "gvkey" y "iid", no es relevante que no contengan "isin".

**NOTA: Debe notarse que un "gvkey" está asociado a un nombre de empresa. Esto implica que si sólo analizamos los "gvkey" encontraremos fechas duplicadas. Pero no sería adecuado eliminar los registros con fechas duplicadas, pues pueden corresponder a una emisión ("iid") diferente.**

Verificamos entonces cuáles son los "gvkey_iid" que tienen alguna fecha duplicada.
```{r}
# Cuales son el combinado de fecha/empresa que aparecen en la base más de una vez
# y los extraemos hacia un vector
DatosMX01 <-unite(DatosMX01, gvkey_iid, c("gvkey","iid"), sep = "_", remove = FALSE, na.rm = FALSE)
filt_dup <- DatosMX01 %>% 
  group_by(datadate, gvkey_iid) %>% 
  count(datadate) %>% 
  filter(n > 1)  %>% 
  mutate(dummy = paste(as.character(datadate),gvkey_iid)) %>% 
  pull(dummy)

# Se crea un dataframe con los registros dupolicados
dups <- DatosMX01 %>%
  mutate(dummy = paste(as.character(datadate), gvkey_iid)) %>%
  filter(dummy %in% filt_dup)

dups
rm(dups,filt_dup)
```
No hay fechas duplicadas.

## Precio ajustado y capitalización de mercado.

Para calcular los precios ajustados, primero revisamos si existen precios(prccd) negativos y luego realizamos los cálculos correspondientes.

```{r}
#Creamos un nuevo data frame, en caso de querer regresar a este punto.
DatosMX02<-DatosMX01 
#Revisamos si hay precios negativos.
DatosMX02 %>% group_by(gvkey_iid) %>% filter(prccd<=0) 
#No se identificaron precios negativos. 
# Vemos que si hay registros con "NA" en el campo "prccd".
DatosMX02 %>% count(is.na(prccd))
#No se identificaron registros con NA en "prccd". Procedemos con los cálculos.
# Para los registros previos al 1 de enero de 1993, dividimos prccd entre 1000 para convertirlos en MXN.
DatosMX02 <- DatosMX02 %>% mutate(prccd=ifelse(curcdd== "MXP",prccd/1000,prccd)) 
# Entonces, calculamos el Precio ajustado.
DatosMX02 <- DatosMX02 %>% mutate(Precio=(prccd/ajexdi)*trfd)
# Calculamos el Valor de Mercado (SIZE).
DatosMX02 <- DatosMX02 %>% mutate(Size=prccd*cshoc/1000000)
```

## Selección por Valor de Mercado.

**En esta sección propongo analizar gráficamente la serie de valor de mercado por cada "gvkey" y sus emisiones (iid) correspondientes, para elegir aquella emisión que mantendremos en la muestra para el ejercicio de burbujas.**

## Filtros de fin de mes.

**Hasta aquí voy. Es posible que además de elegir los registros con "monthend==1", debamos establecer otra condición para identificar algún otro precio observado y evitar tener "missing" values.**

Ahora, nos quedamos unicamente con los "monthend" y creamos la variable de precios con la que se calcularán los retornos.
```{r}
Prueba01<- DatosMX02 %>% 
    select(gvkey_iid,datadate,Precio) %>% 
    mutate(year=year(datadate)) %>% 
    mutate(month=month(datadate)) %>% 
    group_by(year,month) %>% 
    spread(gvkey_iid,Precio)

Prueba02<- DatosMX02 %>% 
    select(gvkey_iid,datadate,monthend,Precio) %>% 
    mutate(year=year(datadate)) %>% 
    mutate(month=month(datadate)) %>% 
    group_by(year,month) %>% 
    spread(gvkey_iid,Precio) %>% 
    filter(monthend==1)

#Creamos un nuevo data frame, en caso de querer regresar a este punto.
DatosMX03 <- DatosMX02
# Dejamos únicamente los registros identificados como "monthend".
DatosMX03 <- DatosMX03 %>% filter(monthend==1)
```

